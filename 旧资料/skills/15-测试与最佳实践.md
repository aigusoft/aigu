# 15｜测试与最佳实践

在 WCEX 项目中，保证可维护性与稳定性的关键在于良好的结构规划、适度的自动化测试以及对框架特性的合理使用。本章汇总项目级建议与 UI 自动化测试方案。

## 15.1 UI 自动化测试
CLI 提供 `wcex test` 命令配合 `puppeteer-core` 执行端到端测试，适合检验多端组合交互（如 PC + 移动端 + 扫码登录场景）。

### 测试目录约定
```
test/
├─ case-a/
│  ├─ testEntry.html     # 测试入口组件
│  ├─ index.html         # 可选，覆盖默认模板
│  ├─ page.json          # 可选，设置 viewport
│  └─ assets/...         # 依赖资源
└─ case-b/...
```
- `testEntry.html` 通过 `<test_entry->` 标签加载业务组件，并在完成后输出 `console.log('WCEX_TEST_END')`。
- CLI 会自动注入 `meta name="npm"` 与 `wcex` 运行时，无需手动编写。
- 可使用 `page.json` 指定浏览器视口（提升多端模拟的准确性）。

### 编写测试示例
```html
<template @ready="run()">
  <meta name="scope" done.bool="0" />
  <app-dashboard $ref="dashboard"></app-dashboard>
  <script scope=".">
    return class {
      async run() {
        await this.$delay(500);
        this.$id.dashboard.$scope.toggleMenu();
        await this.$delay(500);
        console.log("WCEX_TEST_END");
      }
    };
  </script>
</template>
```
- 通过 `$refs`/`$id` 访问子组件并触发交互，最后打印结束标记。
- `wcex test --show` 可在调试阶段观察真实浏览器行为，生产环境可关闭以提升速度。

## 15.2 代码组织最佳实践
1. **组件职责单一**：每个 `.html` 组件应聚焦一个 UI 区块。复杂页面通过组合多个子组件实现，便于复用与测试。
2. **属性与作用域分层**：对外参数通过 `<template>` 属性暴露，内部状态使用 `meta scope` 与 `<script scope>` 管理。避免直接修改 `$props`。
3. **慎用全局样式**：默认情况下，样式应限制在组件内。只有在确实需要统一风格时才使用 `global="import"`。
4. **显式声明依赖**：所有第三方库通过 `<meta name="module">` 声明，让 CLI 和构建工具能够自动管理。
5. **资源路径统一使用 `$path`**：确保组件在不同部署路径或 npm 包中仍能正确引用静态资源。
6. **生命周期显式清理**：在 `onDestroy` 中停止定时器、事件监听、Service Worker 等，防止内存泄漏。
7. **避免表达式副作用**：模板中的 `$`/`:` 表达式应保持纯函数特性，将业务逻辑放入事件处理或 Scope 方法内。
8. **充分利用 `$watch`**：监听数据变化时配合 `$delay` 或 `$next`，防止频繁更新造成抖动。
9. **数据结构可序列化**：在 `meta scope` 中声明对象/数组时保证可序列化，便于调试与持久化。
10. **使用 `.lazy` 避免闪烁**：对需要等待异步数据的属性加上 `.lazy`（如 `title.lazy="calcTitle()"`），让运行时在挂载后再写回 Scope，配合默认的 `.cloak` 样式可避免 FOUC。
11. **循环键稳定**：`$for` 对象以索引或键作为复用依据，排序时请使用稳定的键或在操作前复制数组，避免旧节点被误删。

## 15.3 性能建议
- **合理使用节流/防抖**：高频事件绑定 `.throttle` 或导入 `lodash.throttle`/`lodash.debounce`。
- **按需加载组件**：动态场景使用 `$cmpt` 与 `$if`，避免一次渲染大量未使用的 UI。
- **利用预加载**：对关键 npm 依赖加上 `preload`，减少首次交互延迟。
- **服务端支持**：可结合 Service Worker 缓存（如文档 Playground）提升离线体验。

## 15.4 多端适配与协同
- 使用语义化尺寸与 CSS 变量控制组件在不同视口下的表现，必要时结合 `@media`。
- 将跨端场景拆分为独立测试目录，在 `wcex test` 中通过多浏览器或多视口执行。
- 借助 UI 库的 `side`、`pop`、`dialog` 组件统一交互模式，减少端差异。

## 15.5 调试工具
- `wcex-ui.dev` 提供面板查看组件树、状态、路由；在开发过程中保持开启。
- 利用 `$log` 输出带有组件名和行号的日志，便于定位问题。
- 热更新时若遇到缓存问题，可在浏览器控制台触发 `WCEX.hotReload()`（依据运行时版本提供的 API），或在 Service Worker 中执行 `hotCacheClean`。
- 若需调试 npm 包的本地版本，可向 `localStorage.__DEV` 写入 `{ "pkgs": { "@wcex/ui": { "enable": true, "hostport": "127.0.0.1:8102" }}}`，运行时会自动将相关模块映射到本地并建立热更新通道。

## 15.6 版本管理与构建
- `wcex build` 会自动递增补丁版本，建议在提交前执行一次构建以确保版本更新。
- 将 `dist/` 纳入发布流程或 CI 自动产出，通过 `wcex pack` 打包依赖以便部署。
- 若组件面向 npm 发布，遵循语义化版本号，并在 README 中列出必要的 `meta module` 声明。

通过遵守这些实践，可提升代码质量、自动化程度以及多端一致性，确保 WCEX 项目在持续迭代中保持稳定。

## 智能体提示
- 当需要指导测试，请描述 `test/用例/testEntry.html` 的结构，并提醒脚本结束时输出 `WCEX_TEST_END`。
- 若用户遇到闪烁或初始化延迟，建议给易变属性添加 `.lazy` 并利用 `.cloak` 样式掩护。
- 在讨论性能问题时，可推荐 `.throttle` 修饰符或 `lodash.throttle`，并强调 `$for + $if` 的按需渲染策略。
- 对联调或回归流程的提问，建议组合 `wcex build`、`wcex test` 与版本管理策略，确保产物与测试一致。
