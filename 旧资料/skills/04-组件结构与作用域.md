# 04｜组件结构与作用域

WCEX 组件在一个 HTML 文件内完成结构、数据与逻辑定义。理解 `<template>` 根节点、`meta scope` 数据声明以及 `Scope` 类扩展，是正确生成组件的前提。

## 4.1 `<template>` 根节点
```html
<template title="WCEX" size.int="16" @ready="onReady()">
  <!-- 样式、内容、脚本均放在内部 -->
</template>
```
- `<template>` 必须是组件唯一顶层元素。
- 在 `<template>` 上可直接声明对外属性（props）与事件监听：
  - 属性名允许类型后缀：`count.int="0"`、`visible.bool="1"`、`config.object="{}"`。
  - 事件使用 `@event` 语法（详见第 6 章）。`@ready`、`@create`、`@destroy`、`@timer` 等是框架提供的钩子事件。
- 属性值默认按字符串处理，若携带 `$` 修饰（例如 `<child $data="userInfo">`），则以表达式求值后的原始类型传入，可在组件内部通过 `$props` 直接访问。
- 任何属性后缀 `.lazy` 会在组件挂载后约 50ms 再同步到局部作用域，可避免初始渲染时的闪烁或昂贵计算（源码位于 `Wc._applyElementTemplate`）。

## 4.2 `meta` 标签扩展
### 4.2.1 组件内部数据 (`scope`)
```html
<template>
  <meta name="scope" message="Hello" counter.int="1" options.array="[1,2,3]" />
  <h2 :>${message}(${counter})</h2>
</template>
```
- `meta name="scope"` 定义组件实例的初始数据，会被注入到根 `Scope` 对象；即便模板中未显式书写，运行时也会自动补齐一个空的 `<meta name="scope">` 以便后续脚本引用。
- 支持与 `<template>` 属性一致的类型修饰符，布尔/数值/数组/对象按 JSON 解析。
- 所有通过 `scope` 声明的字段自动参与依赖追踪，可在模板、事件、脚本中直接访问。

### 4.2.2 模块依赖 (`module`)
```html
<template>
  <meta name="module" pkg="@wcex/ui" version="1.1.17" />
  <meta name="module" pkg="lodash.debounce" cjs />
  <meta name="module" pkg="toolcool-color-picker" content="dist/toolcool-color-picker.min.js" preload />
</template>
```
- `pkg`：npm 包名。可以是作用域包（如 `@scope/pkg`）。
- `version`：锁定版本号，CLI 会优先尝试安装与之匹配的版本。
- `url`：自定义包加载地址（用于本地调试或非 CDN 源）。
- `content` / `files`：指定需要加载的具体文件（以 `;` 分隔多个）。
- `cjs` / `esm` / `amd` / `eval`：选择运行时解析方式，默认按 UMD 处理。
- `preload`：在组件初始化前立即加载依赖，适合体积较大的库。
- CLI 在开发模式下会扫描所有 HTML，若发现对应依赖未安装则自动执行 `pnpm/yarn/npm add`。

## 4.3 组件内容与作用域
### 4.3.1 根作用域（Root Scope）
- 每个自定义元素实例关联一个 `Scope` 对象（`rootScope`）。
- 模板内所有带动态绑定的元素都拥有 **局部作用域**，沿 DOM 层级向上继承，最终指向根作用域。
- 在模板、脚本、事件表达式中可直接访问根作用域属性、方法及 `$props`（外部传参）。
- 常用引用：`this.$root`、`this.$rootElem`、`this.$parent`、`this.$id.xxx`（参见第 11 章）。

### 4.3.2 局部作用域与继承
```html
<div $title="'Parent'" $>
  <h3 $>${title}</h3>
  <ul $items="[1,2,3]">
    <li $for="items" :>${index}. ${value} from ${title}</li>
  </ul>
</div>
```
- 在元素上通过 `$foo="..."` 定义的属性同样会进入该元素的局部作用域。
- 子元素可访问父作用域中的变量（如 `title`）；循环内新增的变量（`index`、`value`）仅在当前作用域有效。
- 若需要重命名局部作用域，可使用 `$as="aliasName"`（详见第 7 章）。

### 4.3.3 属性同步与延迟写入
- 作用域属性名若以小写字母开头，会自动映射到元素属性：`scope.class = "btn"` 会同步到 `class`，`scope.dataId = "42"` 会同步到 `data-id`。`class` 会与模板上已存在的类名去重合并。
- 给属性加 `.lazy` 修饰（例如 `title.lazy="calcTitle()"`）时，初始值会在下一异步周期写回 Scope，以避免 `calcTitle` 在模板解析阶段执行。
- Scope 上的 `style` 可直接设置字符串；若更复杂的动态样式需求可参考第 8 章的 CSS 绑定。
- 局部作用域会在 `Wc._initLocalScope` 中通过 `Proxy` 代理，确保 `scope.prop = value` 能触发依赖更新，同时调用 `$parent` 时始终指向最近的祖先作用域。

## 4.4 `<script scope>` 与逻辑扩展
### 4.4.1 引入同名脚本
```html
<template>
  <script scope="." src="."></script>  <!-- 自动加载 app.ts 或 app.js -->
</template>
```
- `scope="."` 表示脚本导出的默认类实例即作为根作用域扩展。
- `src="."` 会寻找与当前组件同名的 `.ts` 或 `.js` 文件；在开发模式下 `.ts` 会由 CLI 编译至 `build/src`。
- TypeScript 文件可直接 `import` 第三方库（需通过 `meta module` 声明或手动安装）。

### 4.4.2 内联返回 Scope 子类
```html
<script scope=".">
  return class {
    message = "Hello";
    onReady() {
      this.$watch(() => this.message, () => this.$log("message changed"));
    }
  };
</script>
```
- `scope="."` 且无 `src` 时，可直接 `return` 一个类或实例；框架会将其与根作用域合并。
- 类内部的属性和方法与 `meta scope` 定义的字段共享同一命名空间。

### 4.4.3 注入第三方库实例
```html
<meta name="module" pkg="lodash.throttle" cjs />
<script scope="throttle" src="lodash.throttle" nocall nowatch></script>
```
- `scope="throttle"` 会在根作用域挂载 `this.throttle`。
- `src="lodash.throttle"` 表示加载刚才声明的 npm 包。
- `nocall`：阻止默认的导出执行（适合 CJS 导出函数的场景，由调用者决定如何调用）。
- `nowatch`：避免将导出结果纳入依赖追踪，提高性能。
- 之后即可在组件中使用 `this.throttle(fn, wait)`。

### 4.4.4 多脚本并存
```html
<script scope="pkg" src="./package.json"></script>   <!-- JSON 将被解析为对象 -->
<script scope="font" src="../utils/font.js"></script>
<script scope=".">return class { /* ... */ }</script>
```
- 可以声明多个 `<script>`，分别注入不同的帮助器或扩展。名称冲突时后者覆盖前者。
- 引入 JSON 文件会自动解析为对象；引入 JS/TS 则按模块方式运行。

## 4.5 本地作用域与 Shadow DOM 的协同
- `<style>` 默认只作用于当前组件 Shadow DOM 内部；如需覆盖全局可在 `<style global>` 或 `<link rel="stylesheet" global="import">` 内声明。
- `:host` 选择器用于设置组件容器样式；`:host([prop])` 可以基于布尔属性切换主题。
- 可通过 `<slot>` 将内容透传给子组件，搭配 `$slot` 对象在脚本中读取插槽状态。运行时会在 `slotchange` 时回填 `assignedElements()` 对应作用域，方便父组件与插槽内部通信。
- 带有 `svg[src]` 的元素会在绑定时自动通过 `WCEX.$path` 拉取远程 SVG 文档并替换子节点，同时继承 `viewBox` 属性，适用于图标库的懒加载。

## 4.6 小结
- 组件由 `<template>`、`meta scope`、`meta module`、`style`、`script` 等结构拼接而成。
- 所有数据、方法、计算属性最终归入 `Scope`，可通过 `$watch`、`$emit`、`$router` 等工具与其他组件通信。
- 正确利用 `scope` 体系和脚本注入，能让自动化系统在保持结构清晰的同时复用第三方能力。

## 智能体提示
- 生成组件模板时，确保 `<template>` 为唯一根，且 `meta scope` 至少存在一个，即使为空也利于脚本复用。
- 当用户需要引入 npm 库，提示同时添加 `<meta name="module">` 与 `<script scope="xxx" src="pkg">`，并根据是否调用默认导出决定 `nocall/nowatch`。
- 若问题涉及局部作用域或循环变量，强调 `$for` 自动注入 `index/value/key`，并可用 `$as` 改名，避免误用父级变量。
- 在解释 Shadow DOM 与样式时，建议优先使用 `:host`、`global` 属性和 `$slot` 组合，提醒插槽状态可通过 `slotchange` 监听。
