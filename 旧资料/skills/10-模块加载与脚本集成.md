# 10｜模块加载与脚本集成

WCEX 支持在纯 HTML 中声明 npm 依赖，并在运行时按需加载。配合 `<script scope>` 可注入第三方库、TypeScript 逻辑或 JSON 配置。本章梳理模块声明、加载模式与常见用法。

## 10.1 `meta name="module"` 语法
```html
<meta name="module" pkg="@wcex/ui" version="1.1.17" />
<meta name="module" pkg="lodash.debounce" cjs />
<meta name="module" pkg="toolcool-color-picker" content="dist/toolcool-color-picker.min.js" preload />
```
| 属性         | 作用                                                                                  |
| ------------ | ------------------------------------------------------------------------------------- |
| `pkg`        | 必填，npm 包名（可含作用域，如 `@scope/name`）。                                      |
| `version`    | 指定版本号，CLI 会优先安装匹配版本。                                                  |
| `url`        | 自定义包根路径，适合连到本地调试服务器或离线镜像。                                   |
| `content`    | 需要加载的具体文件，常用于 CDN 中的构建产物（支持相对路径）。                        |
| `files`      | 半角分号分隔的文件列表，用于一次性声明多个入口。                                     |
| `deps`       | 依赖的其他模块名，多个以 `;` 分隔，加载当前模块前会先调用依赖的 `getResult()`。        |
| `cjs`/`esm`/`amd`/`eval` | 指定加载模式，默认按照 UMD 检测。                                               |
| `preload`    | 组件初始化前预加载并缓存依赖。                                                        |
| `prefix`     | 自定义模块前缀（供运行时识别包结构，少见场景使用）。                                 |
| `global`     | 指定全局变量名称，适用于通过 `<script>` 注入的库（如 CJS 暴露在 `window` 上时）。     |
| `export-name`| 指定命名导出的字段（默认尝试 `default`），适配部分库不提供默认导出的问题。            |
| `cors`       | 将资源的 `fetch` 请求强制开启或关闭 `CORS`，未显式写入时继承 `<meta name="npm">` 的设定。 |

### CLI 对 `meta module` 的处理
- `wcex dev` 启动时遍历项目中的 HTML，收集所有 `pkg` 并检查 `node_modules`。
- 缺失依赖时会根据当前包管理器（`pnpm`/`yarn`/`npm`）自动安装，同时尝试安装对应的 `@types/*`（若包未提供类型声明）。
- 运行时根据 `meta` 配置计算最终资源 URL：默认拼接 `meta[name="npm"]` 设置的 CDN 根（`WCEX.npmUrl` 亦指向该值）。

### 10.1.1 其他相关元标签
- `<meta name="npm" content="…">`：设置 npm 根目录，可选 `cors` 属性决定是否默认携带跨域头。
- `<meta name="root" content="…">`：为非 npm 包组件指定搜索根目录；当加载本地文档或嵌入编辑器时尤为有用。
- `<meta name="debug" content="true">`：允许在控制台输出更多日志，便于定位模块解析问题。
- `<meta name="lang" content="zh-cn">`：写入 `_htmlMeta.lang`，供多语言组件判定当前语言。
- `<meta name="no-import-global-css">`：禁止运行时自动注入依赖包自带的全局样式，适合完全自主控制样式隔离。
- 运行时还会读取 `localStorage.__DEV`，按照配置把指定包重定向到本地 `host:port` 并自动注入对应的 `<meta name="module" url="...">`，常用于一边开发库、一边在主项目中调试。

## 10.2 `<script scope>` 与依赖注入
### 10.2.1 注入第三方库实例
```html
<meta name="module" pkg="lodash.throttle" cjs />
<script scope="throttle" src="lodash.throttle" nocall nowatch></script>
```
- `scope="throttle"` 将模块暴露为 `this.throttle`。
- `src` 指向 `meta` 声明的包名；运行时自动匹配 `.js` 文件。
- 常用标记：
  - `nocall`：阻止对导出的默认函数立即执行（例如 CJS 默认导出函数时很有用）。
  - `nowatch`：跳过依赖追踪，避免 Proxy 包裹模块对象。
  - `async` / `defer`：若脚本需要异步加载，可根据实际情况添加。

### 10.2.2 引入 JSON / 静态资源
```html
<script scope="pkg" src="./package.json"></script>
```
- JSON 会被自动解析并挂载为对象：`this.pkg.version`。
- 同样适用于 `.json` 配置文件、`.js` 导出的常量等。

### 10.2.3 TypeScript 集成
```html
<template>
  <script scope="." src="."></script> <!-- 自动加载同名 .ts/.js -->
</template>
```
- CLI 在开发模式下运行 `tsc -w`，将 `.ts` 编译到 `build/src/`。
- 组件运行时优先加载 `build/src/组件名.js`，实现 TypeScript 与 HTML 解耦。
- TypeScript 文件中可直接 `import` 依赖（需通过 `meta module` 或 `package.json` 声明）。

## 10.3 实战示例
### 10.3.1 动态颜色选择器
```html
<meta name="module" pkg="toolcool-color-picker" content="dist/toolcool-color-picker.min.js" preload />
<toolcool-color-picker button-width="2rem" id="picker" @change="$Colors.set('pri',$ev.detail.hsl)"></toolcool-color-picker>
```
- 直接复用第三方 Web Component，无需额外封装。
- 借助 `$Colors` 更新全局配色。

### 10.3.2 实用工具函数
```html
<meta name="module" pkg="lodash" content="lodash.min.js" />
<input $$value="str">
<div $>lod.kebabCase(str)</div>
<script scope="lod" src="lodash" nowatch nocall></script>
```
- 将通用工具库注入作用域，在模板中直接调用其方法（如 `lod.kebabCase(...)`）。

### 10.3.3 富文本或 Playground 场景
```html
<meta name="module" pkg="lodash.debounce" cjs />
<wcex-ui.monaco $file="playgroundPath(value)" @content="onContentUpdate($ev)"></wcex-ui.monaco>
<script scope="debounce" src="lodash.debounce" nocall></script>
```
- `lodash.debounce` 与编辑器组件结合，实现输入节流与热更新。
- 可结合 Service Worker 或本地存储缓存内容，加快复杂编辑器的启动。

### 10.3.4 热更新与缓存失效
- CLI 推送的 `wc-hotload` 事件会调用 `_umdLoader.removeFileMatched(url)` 清除旧的 JS/SVG 缓存并重新拉取资源。
- 对于模板变更，`HotLoader` 会触发 `_replaceWithNewTag`，在不销毁现有作用域的情况下更新组件，因而能保持输入状态。
- 若自行操作 `WCEX.modules` 或 `UmdLoader`，务必在替换文件后调用 `removeFileMatched` 以防载入旧版本。

## 10.4 与 `WCEX` 全局对象交互
- `WCEX.npmUrl`：当前应用的 npm 资源根（由 `<meta name="npm">` 设置）。
- `WCEX.modules`：已加载模块信息（可用于调试或自定义加载策略）。
- `WCEX.amdloader`：暴露内部 AMD 加载器映射，可在调试时查看未完成的模块请求。
- `WCEX.loadTime`：最近一次页面初始化耗时（毫秒），热更新也会更新该值。
- 扩展框架功能时，可读取这些全局属性保持一致。

## 10.5 模块打包与发布
当需要发布组件库或服务模块时，可使用 CLI 的 `wcex build` / `wcex pack`：
- `wcex pack --pack-dir distPkg`：将项目与依赖拷贝到指定目录，适合离线部署。
- `module.json` + `buildModule`：一次性产出 `html` 与 `service` 子项目，生成包含版本号的包结构。

## 10.6 注意事项
- `meta module` 只声明依赖，不会自动导入。需要结合 `<script>`、`<link>` 或直接引用其自定义元素。
- 引入 CJS 模块时若缺乏默认导出，可以结合 `global` 属性或在脚本中处理命名空间。
- 若通过 `url` 指向本地服务器，确保路径与 CDN 保持同样的目录结构，免得 `@` 路径解析失败。
- 为避免冷启动延迟，可对关键依赖使用 `preload` 或在入口 HTML 统一声明。

通过这些机制，可以在 WCEX 中稳健地复用 npm 生态、TypeScript 辅助代码或自定义工具，使生成的页面具备完整的工程化能力。

## 智能体提示
- 在回答“如何引入 npm 包”时，优先提供 `<meta name="module">` 模板，并说明 `pkg + version + content/url` 的组合。
- 当问题涉及脚本注入，提醒用户 `<script scope>` 的 `scope` 名称会成为作用域属性，必要时使用 `nocall/nowatch` 避免副作用。
- 若用户想连调本地包，提示可在 `localStorage.__DEV` 中配置 `pkgs`，或手动写 `<meta name="module" url="http://localhost:xxxx/">`。
- 解释 TypeScript 集成时，强调 `src="."` 寻找同名 `.ts/.js`，CLI 会从 `build/src` 提供编译结果。
