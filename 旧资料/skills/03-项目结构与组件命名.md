# 03｜项目结构与组件命名

WCEX 组件是纯 HTML 文件，依靠约定俗成的目录与命名即可在运行时被解析并注册为自定义元素。本章汇总项目规划与标签命名的全部规则。

## 3.1 标准目录结构
建议按照以下方式组织前端项目（`wcex init` 默认生成类似布局）：
```
project/
├─ index.html            # 应用入口（脚手架、全局 meta、外链脚本）
├─ app.html              # 入口组件，自定义标签 <app->
├─ components/           # 业务组件目录（可再分模块）
│   ├─ header/
│   │   ├─ mainNav.html
│   │   └─ mainNav.ts
│   └─ footer.html
├─ assets/               # 静态资源（图片、字体等）
├─ scripts/              # 独立脚本（可通过 <script src> 引入）
├─ package.json
└─ tsconfig.json         # 可选，启用 TypeScript 时提供
```
`wcex` 运行时根据标签名计算相对路径：
- 若当前页面位于 `project/index.html`，则 `<components-header.main_nav>` 对应 `components/header/mainNav.html`。
- 若页面位于子目录（例如 `components/index.html`），标签解析时会以该 HTML 所在目录作为根路径。

## 3.2 `<template>` 根节点与属性声明
- 每个组件文件必须以单个 `<template>` 元素为根。
- `<template>` 自身的属性即组件的对外接口，可使用类型修饰后缀：
  - `prop.bool="0"` → Boolean
  - `size.int="16"` → Number（整数）
  - `options.array="[]"` / `config.object="{}"` → JSON 解析
  - 未加类型默认为字符串。
- 组件使用方可通过常规 HTML 属性传参：`<my-card title="Hello" $data="sourceObj">`。
- 若属性名为 `value`，组件将自动与 `$$` 双向绑定语义对齐，表现类似原生 `input`。

## 3.3 标签命名转换规则
组件文件名采用 **小驼峰**，运行时转换为符合 Web Components 规范的小写短横线标签。具体规则：
1. 将文件名中的大写分隔为小写并以 `_` 连接：`helloWorld.html` → `hello_world`。
2. 每级目录以 `-` 连接：`components/main/navBar.html` → `components-main-nav_bar`。
3. 若最终结果不包含 `-`，会在尾部补一个 `-`（符合浏览器自定义元素要求）。
4. 引用时可以使用“短名”或“全名”：
   - **短名**：相对当前入口 HTML 的路径，适用于项目内部引用。`<main-nav>` → `main.html` 同级 `mainNav.html`。
   - **全名**：`包名.组件名`，用于跨包引用或通过 npm 发布的组件库。例：
     - 包 `abc` 的 `com1.html` → `<abc.com1->`
     - 包 `@pkg/ui` 的 `btn.html` → `<pkg-ui.btn>`（移除 `@` 后按目录拼接）。
5. 当从其他 npm 包加载组件时，确保在入口或组件内声明 `<meta name="module" pkg="@pkg/ui">`（详见第 9 章）。

### 示例
```
src/
├─ index.html            # 浏览器打开的入口
├─ app.html
├─ dashboard/
│   ├─ index.html        # 访问 /dashboard/index.html 时，根路径随之改变
│   └─ statsPanel.html
└─ widgets/
   └─ userCard.html
```
- 框架自身的核心源码位于 `node_modules/wcex/src/`，包含响应式系统、模板解析器、模块加载器与默认插件（`plugins/$color.ts`、`plugins/$monitSize.ts` 等）；如需排查运行时行为或编写自定义插件，可引用这些实现作为参考。
- 自带 UI 库 `@wcex/ui` 采用相同约定，组件均放置在包内的 `src/` 目录，可直接阅读 HTML/TS 文件了解属性和插槽约定。
- 访问 `index.html`：
  - `<app->` → `app.html`
  - `<dashboard-stats_panel>` → `dashboard/statsPanel.html`
  - `<widgets-user_card>` → `widgets/userCard.html`
- 访问 `dashboard/index.html`：
  - `<stats-panel>` → `dashboard/statsPanel.html`
  - `<widgets-user_card>` 仍然可用，因为子目录只能引用自身及其子级，想访问上级需使用包全名或调整目录结构。

## 3.4 组件引用与跨包场景
| 场景                     | 写法示例                                      | 说明                                                         |
| ------------------------ | --------------------------------------------- | ------------------------------------------------------------ |
| 同目录组件互相引用       | `<profile-card>`                              | 组件文件位于同一路径，使用短名即可。                         |
| 子目录访问上级目录组件   | `<../shared-modal>` ⛔                        | 不支持 `../`，请改用全名或调整结构。                         |
| 主项目引用 npm 组件库    | `<wcex-ui.btn>`                               | 在页面或组件根添加 `<meta name="module" pkg="@wcex/ui">`。    |
| npm 组件引用另一个 npm 包 | `<pkg-ui.list>`                               | 对应包需声明依赖并在 `package.json` 发布。                   |
| 组件名称包含中文         | `中国/测试.html` → `<中国-测试>`              | 支持 Unicode，转换时按原字符保留，仍需至少有一个 `-`。        |

## 3.5 入口文件中的全局资源
- `<meta name="npm">`：决定默认 npm 解析地址（配合跨包引用）。
- `<link rel="stylesheet" global="import">`：在组件内引入全局样式（详见第 8 章），适用于 UI 库等。
- `<meta name="module" pkg="...">`：预声明全局依赖，避免首次使用组件时的延迟加载。
- `<meta name="colors">`：设置全局配色模式，对所有子组件生效。

## 3.6 推荐实践
- 使用有意义的目录层次划分功能区（如 `dashboard/`, `forms/`, `user/`），并在组件标签中保留模块前缀以避免冲突。
- 将资源、脚本与组件文件放在同一路径结构，便于 `$path()` 计算相对地址。
- 发布 npm 组件库时，保持包名与目录名一致，方便通过 `<包名.组件>` 访问。
- 若需要复用第三方 Web Component（如 `toolcool-color-picker`），在自定义组件内声明 `meta module` 并复用原生标签，不必二次封装。

## 3.7 运行时代码结构速览
- `src/Wc.ts`：自定义元素的宿主类，负责模板克隆、局部作用域创建、依赖追踪、`$if/$for/$show` 等结构化指令。
- `src/Tpl.ts`：HTML 模板解析器，对 `$for`、`$if`、`$$`、`$:`、`.lazy` 等语法糖进行预处理并生成绑定函数。
- `src/Observer.ts`：轻量响应式内核，基于 `Proxy` 和 `requestAnimationFrame` 批量派发依赖更新。
- `src/UmdLoader.ts`：模块加载器，支持 CJS/AMD/ESM 自动适配及插件式 `require`。
- `src/plugins`：内置插件目录，可作为实现自定义插件的模板；通过 `WCEX.usePlugins` 注册后即可在模板解析、Scope 初始化和属性更新阶段介入。

通过遵循以上规则，框架即可在运行时快速解析标签与文件映射，为自动化生成和人类维护都提供统一约束。

## 智能体提示
- 生成标签名时始终执行“目录 + 文件 + 驼峰转短横线”三步，可引用第 3.3 节的规则避免命名冲突。
- 回答组件互相引用的问题时，强调“不支持 `../`”，并建议使用全名 `<包名.组件>`。
- 当需要解释 `meta module` 或配色设置来源时，可引用 3.5 节的全局资源表，提醒用户在入口 HTML 内统一声明。
- 若用户想把第三方 Web Components 纳入项目，先提示在组件中声明 `meta module` 并遵循同样的目录与命名约定。
