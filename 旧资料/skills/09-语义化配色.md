# 09｜语义化配色

语义化配色由运行时内置的 `$color` 插件提供，所有组件无需额外引入即可获得统一的色板与主题切换能力。本章介绍 `$color` / `$Colors` 的结构、初始化流程、HSL 快捷写法以及常见的自定义策略。

## 9.1 体系概览
- 框架启动时自动注册 `$color` 插件，在每个组件的作用域注入两个对象：`$color`（响应式语义色表）与 `$Colors`（主题管理器）。
- 语义色字段包括 `pri/pria`, `sec/seca`, `text/texta/textr`, `bg/bga/bgr`, `ok`, `warn`, `error`, `info`, `none` 等，类型均为 `Hsla`。
- 运行时会把色表挂到 `window.__COLORS`，便于在调试工具或控制台快速查看当前色值与主题模式。

## 9.2 初始化顺序
颜色值按以下优先级加载（高 → 低）：
1. **`localStorage.__COLORS` / `__COLOR_MODE`**：通过 `$Colors.set`、`setMode`、`switchMode` 写入的本地首选项。
2. **`<meta name="colors">`**：可在入口 HTML 定义默认模式与色值，例如：  
   ```html
   <meta name="colors" mode="0" pri="hsl(100,50%,50%)" sec="hsl(35,70%,55%)" />
   ```
3. **框架默认色板**：当上述配置缺失时使用，主色 `pri` 默认为 `hsla(220,70%,50%,1)`，并自动推导 `sec`、`text`、`bg` 等衍生色。

若 `<html>` 标签带有 `color` 属性，插件会更新根元素的 `style.color`、`style.backgroundColor` 与 `--color-mode` 变量，使全局样式可感知当前主题。

## 9.3 语义色字段
| 字段  | 说明                                  | 常见用途                         |
| ----- | ------------------------------------- | -------------------------------- |
| `pri` / `pria` | 主色及变体                     | 品牌按钮、悬浮态                 |
| `sec` / `seca` | 辅色及变体                     | 次级操作、标签                   |
| `text` / `texta` / `textr` | 正文字色、弱化文本、反相文字 | 主体内容、副标题、深色背景文字   |
| `bg` / `bga` / `bgr` | 背景、条纹、反相背景      | 容器、分割区、暗色模式块         |
| `ok` / `warn` / `error` / `info` | 状态色集合 | 成功、警告、失败、信息提示       |
| `none` | 透明色 (`hsla(0,0%,0%,0)`)            | 占位或动画过渡                   |

所有字段都可继续调用 `Hsla` 的方法或快捷属性，例如 `$color.pri.l3`、`$color.bg.h1_`。

## 9.4 `Hsla` API 与快捷写法
- `h(level)` / `hh(level)`：相对或绝对改变色相（度数）。
- `s(level)` / `ss(level)`：调整饱和度（百分比）。
- `l(level)` / `ll(level)`：调整亮度；在暗色模式会自动反向以保持对比度。
- `a(level)` / `aa(level)`：改变透明度。
- 快捷属性 `h1`~`h9`、`h1_`~`h9_`（以及 `s*`、`l*`、`a*`）按固定粒度偏移：`h` 每档 18°，`s/l` 每档 5%，`a` 每档 10%。`_` 结尾表示负向偏移。
- `Hsla.from(string)` 可从 `hsl/hsla/rgb/rgba/#rrggbb` 转换为 `Hsla` 对象，便于把第三方色值注入语义色。

## 9.5 在模板与样式中使用
- **属性绑定**：`<wcex-ui.icon $color="$color.pri"></wcex-ui.icon>`。
- **文本或表达式**：`<p :>主色：${$color.pri}</p>`。
- **样式表**：在 `<style>` 内使用 `"$color.xxx"`（转字符串）或 `"$$color.xxx"`（保留原格式），例如：  
  ```css
  button {
    color: "$$color.textr";
    background: "$$color.pri.l2";
  }
  ```
- **脚本内引用**：`this.$color.pri`、`this.$color.bg.l2` 等，可直接传给第三方组件或算法。

## 9.6 `$Colors` API
- `mode`：当前主题编号，可用于切换按钮或显示状态。
- `colors`：与 `$color` 指向同一响应式对象，适合调试或批量修改。
- `set(name, hslString)`：覆盖指定语义色并写入 `localStorage.__COLORS`。
- `setMode(mode)` / `switchMode()`：切换主题模式并更新 `__COLOR_MODE`。
- `load()`：重新载入色表（一般由 `set`/`setMode` 自动调用）。
- `Hsla`：暴露构造函数，方便手动创建色值。

示例：
```html
<button @click="$Colors.switchMode()">切换主题</button>
<button @click="$Colors.set('pri', `hsl(${index*18},70%,50%)` )">随机主色</button>
```

## 9.7 自定义与持久化策略
1. **入口配置**：在主 HTML 写入 `<meta name="colors">` 以统一默认色值与模式。
2. **运行时个性化**：通过 `$Colors.set/switchMode` 即可实时更新主题，并自动持久化到 `localStorage`。
3. **外部调色器**：将色彩选择器的输出传给 `$Colors.set('pri', newHsl)`，即可让用户自定义颜色。
4. **全局调试**：在控制台访问 `__COLORS.colors` 可查看或临时修改当前色表。

## 9.8 最佳实践
- 始终引用 `$color.*` 而非硬编码 HEX 值，确保主题切换时 UI 保持一致。
- 当需要细微色差时，优先使用 `Hsla` 的链式方法（如 `.l2`、`.h1_`），避免在多个地方重复计算。
- 需要区别浅/深模式时，可读取 `$Colors.mode` 或监听本地存储变化；必要时在 `<html>` 加 `color` 属性辅助全局样式。
- 组件对外暴露颜色配置时，建议直接封装对 `$Colors.set` 的调用，让终端用户的选择立即作用于语义色。

## 智能体提示
- 解释主题切换时，强调 `$Colors.switchMode()` 会同步更新本地存储与 DOM，无需自行维护状态。
- 若问题涉及自定义色值，建议用 `$Colors.set('pri', 'hsla(...)')` 并说明可通过 `Hsla.from` 转换第三方格式。
- 在样式绑定示例中提醒使用 `"$color.xxx"` / `"$$color.xxx"`，避免遗忘引号或误用普通字符串。
- 当用户需要读取当前色值或调试主题，提示 `window.__COLORS` 可用于快速观察与试验。
