# 06｜事件与生命周期

事件系统沿用 Vue 风格的 `@event` 语法，同时暴露 Web Components 生命周期钩子。理解修饰符、定时器事件与 `Scope` 中的钩子方法，有助于组合复杂交互。

## 6.1 事件绑定基础
```html
<button @click="count++" @mouseenter="onHover($ev)">
  Hover me
</button>
```
- `@事件名="表达式"`：绑定 DOM 或自定义事件。表达式可访问当前作用域变量、`this`（指向根 `Scope`）以及 `$ev`（事件对象）。
- 同一元素可绑定多个事件，表达式将按书写顺序执行。
- 编译阶段会将表达式转换为函数（`mkScopedEvent`），运行时通过 `eid|@event` 键管理监听器，便于在组件重渲染时复用而无需重新绑定。

### 修饰符
WCEX 复用了常见修饰符，并扩展了节流写法：
| 修饰符                | 行为说明                                           |
| --------------------- | -------------------------------------------------- |
| `.once`               | 监听一次后自动移除                                 |
| `.prevent`            | 调用 `event.preventDefault()`                     |
| `.stop`               | 调用 `event.stopPropagation()`                    |
| `.capture`            | 使用事件捕获阶段触发回调                           |
| `.self`               | 仅当事件由当前元素触发时执行                      |
| `.throttle` / `.N`    | 以毫秒为单位节流；`.throttle` 默认 100ms，`.1000` 表示 1s |
| `.1`、`.2`……          | 语法糖，等价于 `.100`、`.200` 等（见示例 `@click.1`） |

示例：
```html
<div @click.self.stop.capture="select()" @mousemove.500="syncPosition($ev)"></div>
```

## 6.2 组件级生命周期事件
可以直接在 `<template>` 上监听：
- `@create`：组件实例被创建但尚未渲染时触发。
- `@ready`：组件初次渲染并插入文档后触发，常用于初始化逻辑。
- `@destroy`：组件从文档中移除时触发。
- `@timer[.interval]`：自动创建、清理的定时器事件。默认间隔 1000ms，首次会在 `requestAnimationFrame` 中立即执行一次，再进入周期性回调，可写成 `@timer.2000="tick()"`。
- `@router-change`：当关联路由发生变化时触发（常用于路由容器或依赖 `$router` 的组件）。
- 其他 DOM 事件同样可在 `<template>` 上监听，回调的 `this` 指向根作用域。

示例：
```html
<template @create="init()" @ready="fetchData()" @destroy="dispose()" @timer.500="poll()">
  ...
</template>
```

## 6.3 Scope 生命周期钩子
在 `<script scope=".">` 定义的类中，可实现下列常用方法：
| 方法名         | 调用时机 / 说明                                  |
| -------------- | ----------------------------------------------- |
| `onCreate()`   | 等价于 `@create`，常用于准备数据或注册事件。     |
| `onReady()`    | 组件节点挂载完成，适合访问 DOM、读取 `$id`。    |
| `onDestroy()`  | 组件即将销毁，可在此清理定时器、事件监听等资源。 |
| `onStop()`     | 可由业务调用（例如 `doc.ts` 中终止 TTS 播放）；不是系统级事件，而是自定义约定。 |
| `onRouterChange(route)` | 与 `@router-change` 配合，处理路由切换。             |

`onCreate(doc: DocumentFragment)` 会收到克隆后的模板片段，可在插入 Shadow DOM 之前对其做最后一次改写（例如添加调试节点或预处理数据）。

示例：
```html
<script scope=".">
  return class {
    timer = 0;
    onCreate() {
      this.$log("component created");
    }
    onReady() {
      this.$watch(() => this.counter, () => this.syncTitle());
    }
    onDestroy() {
      clearInterval(this.timer);
    }
  };
</script>
```

## 6.4 访问事件对象与工具方法
- 事件表达式中使用 `$ev` 获取原生事件：`@click="handle($ev)"`。
- 作用域方法内可直接接收事件对象：`onHover(ev) { ... }`。
- 使用 `$emit(name, detail?, toElement?)` 触发自定义事件（参见第 11 章）。示例：`@click="$emit('switch', value)"`。

## 6.5 定时任务与节流
利用 `@timer` 与 `this.$watch` 可轻松实现实时更新：
```html
<template @timer.2000="loadStats()">
  <meta name="scope" stats.obj="{}" />
  <div $>stats.value</div>
</template>
```
在脚本中，可使用 `$delay(ms)`、`$next()`、`$step()` 管控异步节奏（详见第 11 章）。
- `$timer` 与 `$watch` 结合时应牢记：定时器回调内部修改的任意响应式字段都会触发绑定重新执行；若需要节流，可在表达式中配合 `.throttle` 或自定义库函数。

## 6.6 组合第三方库的事件
通过 `<meta name="module">` 与 `<script scope>` 引入第三方库后，可以直接在事件处理器内调用。例如：
```html
<meta name="module" pkg="lodash.throttle" cjs />
<script scope="throttle" src="lodash.throttle" nocall></script>

<div @scroll.throttle="onScroll($ev)"></div>
<script scope=".">
  return class {
    onScroll(ev) {
      this.throttle(() => this.calcPosition(ev), 200);
    }
  }
</script>
```

## 6.7 实战片段
示例：
```html
<template @ready="calc()">
  <meta name="scope" man="World" chars.int="0" />
  <h1 :>双向绑定-HELLO: ${man}, 字符数: ${chars}</h1>
  <input $$value="man" />
  <script scope=".">
    return class {
      onReady() {
        this.$watch(() => this.man, () => this.$delay(0).then(() => this.calc()));
      }
      calc() {
        this.chars = this.man.length;
      }
    };
  </script>
</template>
```
此片段演示了：
- `@ready` 触发初始化方法。
- `$watch` 监听数据变化，结合 `$delay` 在下一异步帧更新依赖。
- 自定义方法 `calc()` 内直接操作 `Scope` 字段。

## 6.8 建议
- 事件内尽量少写复杂逻辑，调用 `Scope` 方法保持可测试性。
- 对高频事件（`scroll`、`mousemove`）务必搭配 `.throttle` 或 `.once` 等修饰符，避免性能问题。
- 结合 `@timer` 与 `onDestroy` 可形成“创建即启动、销毁即清理”的模式，减少内存泄露风险。

掌握上述事件与生命周期语法，便能在不借助外部框架的情况下实现响应式交互、定时任务和路由联动。

## 智能体提示
- 解释事件语法时优先描述 `@event` + 修饰符写法，并提醒 `$ev` 始终可用，避免误写成 `event`。
- 当用户提到“组件初始化/销毁”，指向 `<template>` 级别的 `@create/@ready/@destroy` 或 `Scope` 的 `onCreate/onReady/onDestroy`，说明两者等价但写法不同。
- 对需要定时或轮询的场景，建议使用 `@timer.N` 而不是手动 `setInterval`，并提示在销毁时无需额外清理。
- 若问题涉及第三方库的节流/防抖，说明可通过 `<meta module>` + `<script scope>` 注入库，再在事件回调中调用，保持模块化。
